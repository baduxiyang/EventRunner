{"name":"My QA","type":"com.fibaro.deviceController","apiVersion":"1.2","initialProperties":{"viewLayout":{"$jason":{"body":{"header":{"style":{"height":"0"},"title":"quickApp_device_299"},"sections":{"items":[{"components":[{"components":[{"name":"b1","style":{"weight":"0.50"},"text":"B1","type":"button"},{"name":"b2","style":{"weight":"0.50"},"text":"B2","type":"button"}],"style":{"weight":"1.2"},"type":"horizontal"},{"style":{"weight":"0.5"},"type":"space"}],"style":{"weight":"1.2"},"type":"vertical"},{"components":[{"name":"b3","style":{"weight":"1.2"},"text":"B3","type":"button"},{"style":{"weight":"0.5"},"type":"space"}],"style":{"weight":"1.2"},"type":"vertical"},{"components":[{"name":"uiversion","style":{"weight":"1.2"},"text":"v0.2","type":"label"},{"style":{"weight":"0.5"},"type":"space"}],"style":{"weight":"1.2"},"type":"vertical"}]}},"head":{"title":"quickApp_device_299"}}},"uiCallbacks":[{"callback":"clickA","eventType":"onReleased","name":"b1"},{"callback":"clickB","eventType":"onReleased","name":"b2"},{"callback":"clickC","eventType":"onReleased","name":"b3"}],"quickAppVariables":[],"typeTemplateInitialized":true},"files":[{"name":"main","isMain":true,"isOpen":true,"content":"\nfunction QuickApp:onInit()\n  self:debug(self.name ,self.id)\nend\n"},{"name":"Toolbox","isMain":false,"isOpen":false,"content":"--[[\n  Toolbox.\n  \n  Additional QuickApp functions for logging and loading other toolbox modules.\n  This is not strictly a \"module\" as it is neccessary for the other modules\n\n  Debug flags:\n  self._SILENT == true will supress startup log messages from the toolbox initialization phase\n  self._2JSON == true will convert tables to json strings before printing (debug etc)\n  self._DEBUG == false will inhibit all self:debug messages\n  self._TRACE == false will inhibit all self:trace messages\n  self._NOTIFY == true will create NotificationCenter messages for self:error and self:warning\n  self._NOTIFYREUSE == true will reuse notifications with same title\n  self._INSTALL_MISSING_MODULES == true will try to install missing modules from github reppository\n  self._HTML == true will format space/nl with html codes for log with self:*f functions\n  self._PROPWARN == true will warn if property don't exist when doing self:updateProperty. Default true\n  self._ONACTIONLOG == false will inhibit the 'onAction' log message. Default false\n  \n  Children will be loaded if there are any children (and module 'child' is loaded)\n  quickAppVariables will be loaded into self.config\n  Ex. a quickAppVariable \"Test\" with value 42 is available as self.config.Test\n\n  function QuickApp:setView(elm,prop,fmt,...)         -- Like updateView but with format\n  function QuickApp:getView(elm,prop)                 -- Get value of view element\n  function QuickApp:setName(name)                     -- Change name of QA\n  --function QuickApp:setType(typ)                      -- Change type of QA\n  function QuickApp:setIconMessage(msg,timeout)       -- Show text under icon, optional timeout to remove message\n  function QuickApp:setEnabled(bool)                  -- Enable/disable QA\n  function QuickApp:setVisible(bool)                  -- Hide/show QA\n  function QuickApp:addInterfaces(interfaces)         -- Add interfaces to QA\n  function QuickApp:notify(priority, title, text)     -- Create notification\n  function QuickApp:debugf(fmt,...)                   -- Like self:debug but with format\n  function QuickApp:tracef(fmt,...)                   -- Like self:trace but with format\n  function QuickApp:errorf(fmt,...)                   -- Like self:error but with format\n  function QuickApp:warningf(fmt,...)                 -- Like self:warning but with format\n  function QuickApp:encodeBase64(data)                -- Base 64 encoder\n  function QuickApp:basicAuthorization(user,password) -- Create basic authorization data (for http requests)\n  function QuickApp:version(<string>)                 -- Return/optional check HC3 version\n\n--]]\nlocal QA_toolbox_version = \"0.25\"\nQuickApp = QuickApp or {}\nlocal format = string.format\nlocal _init = QuickApp.__init\nlocal _onInit = nil\nToolbox_Module,modules = Toolbox_Module or {},modules or {} -- needs to be globals\n\nfunction QuickApp.__init(self,...) -- We hijack the __init methods so we can control users :onInit() method\n  _onInit = self.onInit\n  self.onInit = self.loadToolbox\n  _init(self,...)\nend\n\n_debugFlags = _debugFlags or { }\nlocal fetchFiles\n\nfunction QuickApp:loadToolbox()\n  if not __fibaro_get_device(self.id).enabled then  \n    self:debug(\"QA \",self.name,\" disabled\")\n    return \n  end\n  if self.properties.model ~= \"ToolboxUser\" then\n    self:updateProperty(\"model\",\"ToolboxUser\")\n  end\n  self.debugFlags = _debugFlags\n  quickApp = self \n  self._2JSON = true             -- Automatically convert tables to json when logging - debug/trace/error/warning\n  self._DEBUG = true             -- False, silence self:debug statements\n  self._TRACE = true             -- Same for self:trace\n  self._HTML = not hc3_emulator  -- Output HTML debug statements (line beaks, spaces)\n  self._PROPWARN = true\n  self._ONACTIONLOG = false\n  self._NOTIFY = true            -- Automatically call notifyCenter for self:error and self:warning\n  self._UNHANDLED_EVENTS = false -- Log unknow events\n  local d = __fibaro_get_device(self.id)\n  local function printf(...) self:debug(format(...)) end\n  printf(\"QA %s - version:%s (QA toolbox %s)\",self.name,_version or \"1.0\",QA_toolbox_version)\n  if not self._SILENT then\n    printf(\"DeviceId..:%d\",d.id)\n    printf(\"Type......:%s\",d.type)\n    printf(\"Interfaces:%s\",json.encode(d.interfaces or {}))\n    printf(\"Room......:%s\",d.roomID or 0)\n    printf(\"Visible...:%s\",tostring(d.visible))\n    printf(\"Created...:%s\",os.date(\"%c\",d.created or os.time()))\n    printf(\"Modified..:%s\",os.date(\"%c\",d.modified or os.time()))\n  end\n  Toolbox_Module['basic'](self)\n\n--  function QuickApp:loadModule(name,args)\n--    args = args or {}\n--    if Toolbox_Module[name] then\n--      if not self._SILENT then self:debugf(\"Setup: %s (%s)\",Toolbox_Module[name].name,Toolbox_Module[name].version) end\n--      return Toolbox_Module[m].init(self,args)\n--    else \n--      self:warning(\"Module '\"..name..\"' missing\")\n--      if self._INSTALL_MISSING_MODULES then\n--        self.missingModules[#missingModules+1]=name\n--      else self:warning(\"Set self._INSTALL_MISSING_MODULES=true to load missing modules\") end\n--    end \n--  end\n\n  -- Load modules\n  local ms,Module,missingModules = {},Toolbox_Module,{}\n  \n  function self:require(name,...)\n    if Module[name] then\n      local inited,res = Module[name].inited,Module[name].init(self,...)\n      if (not inited) and (not self._SILENT) then \n        self:debugf(\"Setup: %s (%s)\",Module[name].name,Module[name].version)\n      end\n      return res\n    else error(\"Module '\"..name..\"' missing\") end\n  end\n  \n  for _,m in ipairs(modules or {}) do \n    local args = {}\n    if type(m)=='table' then args = m.args or {}; m = m.name end\n    if Module[m] then self:require(m,args)\n    else \n      self:warning(\"Module '\"..m..\"' missing\")\n      if self._INSTALL_MISSING_MODULES then\n        missingModules[#missingModules+1]=m\n      else self:warning(\"Set self._INSTALL_MISSING_MODULES=true to load missing modules\") end\n    end\n  end\n\n  local function cont() -- stuff to do when we loaded missing modules...\n    --for m,_ in pairs(Module) do Module[m] = nil end\n    self.config = {}\n    for _,v in ipairs(self.properties.quickAppVariables or {}) do\n      self.config[v.name] = v.value\n    end\n    if self.loadChildren then\n      local nc = self:loadChildren()\n      if nc == 0 then self:debug(\"No children\") else self:debugf(\"%d children\",nc) end\n    end\n    self.loadToolbox = function() end\n    if _onInit then _onInit(self) end\n    if self.main and type(self.main)=='function' then \n      setTimeout(function() \n          local stat,res = pcall(function() self:main() end)\n          if not stat then self:error(\"main() error:\",res) end\n        end,0) \n    end -- If we have a main(), call it...  \n  end\n\n  -- Try to load missing modules\n  if #missingModules > 0 then\n    local  content = {}\n    fetchFiles(missingModules,content,\n      function()\n        if #content>0 then\n          if not hc3_emulator then\n            self:debugf(\"Adding module(s) ..will  restart\")\n            for _,f in ipairs(content) do\n              api.post(\"/quickApp/\"..self.id..\"/files\",f)\n            end\n            plugin.restart(self.id)\n          else self:debugf(\"Can't update offline\") end\n          cont()\n        end \n      end)\n  else cont() end\n\n  local mpath = \"https://raw.githubusercontent.com/jangabrielsson/EventRunner/master/Toolbox/\"\n  local moduleMap={\n    childs      = {name=\"Toolbox_child\",      url=mpath..\"Toolbox_child.lua\"},\n    events      = {name=\"Toolbox_events\",     url=mpath..\"Toolbox_events.lua\"},\n    triggers    = {name=\"Toolbox_triggers\",   url=mpath..\"Toolbox_triggers.lua\"},\n    rpc         = {name=\"Toolbox_rpc\",        url=mpath..\"Toolbox_rpc.lua\"},\n    file        = {name=\"Toolbox_files\",      url=mpath..\"Toolbox_files.lua\"},\n    pubsub      = {name=\"Toolbox_pubsub\",     url=mpath..\"Toolbox_pubsub.lua\"},\n    profiler    = {name=\"Toolbox_profiler\",   url=mpath..\"Toolbox_profiler.lua\"},\n    ui          = {name=\"Toolbox_ui\",         url=mpath..\"Toolbox_ui.lua\"},\n    LuaCompiler = {name=\"Toolbox_luacompiler\",url=mpath..\"Toolbox_luacompiler.lua\"},\n    LuaParser   = {name=\"Toolbox_luaparser\",  url=mpath..\"Toolbox_luaparser.lua\"},\n  }\n\n  function fetchFiles(files,content,cont)\n    local req = net.HTTPClient()\n    if #files == 0 then return cont() end\n    local f0 = files[1]\n    table.remove(files,1)\n    local f = moduleMap[f0]\n    if not f then quickApp:errorf(\"No module %s\",f0) return fetchFiles(files,content,cont) end\n    quickApp:debugf(\"Fetching module  %s\",f0)\n    req:request(f.url,{\n        options = {method = 'GET', checkCertificate = false, timeout=20000},\n        success = function(res) \n          if res.status == 200 then\n            content[#content+1]={name=f.name,content=res.data,isMain=false,isOpen=false,type=\"lua\"}\n            fetchFiles(files,content,cont)\n          else quickApp:errorf(\"Error %s fetching file %s\",res.status,f.url) end\n        end,\n        error  = function(res) \n          quickApp:errorf(\"Error %s fetching file %s\",res,f.url)\n          fetchFiles(files,content,cont)\n        end\n      })\n  end\nend\n\nfunction Toolbox_Module.basic(self)\n-- tostring optionally converting tables to json or custom conversion\n-- If a table has a __tostring key bound to a function that function will be used to convert the table to a string\n  local _tostring = tostring\n  self._orgToString= tostring -- good to have sometimes....\n  function tostring(obj) \n    if type(obj)=='table' then\n      if obj.__tostring then return obj.__tostring(obj)\n      elseif self._2JSON then return json.encode(obj) end\n    end\n    return  _tostring(obj) \n  end\n\n  local function _format(fmt,...)\n    local args = {...}\n    if #args == 0 then return fmt end\n    for i,v in ipairs(args) do if type(v)=='table' then args[i]=tostring(v) end end\n    return format(fmt,table.unpack(args))\n  end\n  --self._format = _format \n\n  function assertf(test,...) if not test then error(_format(...)) end end\n\n  local function _print(s,fun,...)\n    local res = {}\n    for _,obj in ipairs({...}) do res[#res+1]=tostring(obj) end\n    res = table.concat(res)\n    fun(s,res)\n    return res\n  end\n\n  local htmlCodes={['\\n']='<br>', [' ']='&nbsp;'}\n  local function _printf(self,fun,fmt,...)\n    local str,str2,t1,t0,c1 = _format(fmt,...),nil,__TAG,__TAG\n    str2=str\n    if self._HTML and not hc3_emulator then \n      str2 = str2:gsub(\"([\\n%s])\",function(c) return htmlCodes[c] or c end)\n      str2 = str2:gsub(\"(#T:)(.-)(#)\",function(_,t) t1=t return \"\" end)\n      str2 = str2:gsub(\"(#C:)(.-)(#)\",function(_,c) c1=c return \"\" end)\n    end\n    if c1 then str2=string.format(\"<font color=%s>%s</font>\",c1,str2) end\n    __TAG = t1; fun(self,str2); __TAG = t0\n    return str\n  end\n\n  function self:printTagAndColor(tag,color,fmt,...)\n    assert(fmt,\"print needs tag, color, and args\")\n    fmt = _format(fmt,...)\n    local t = __TAG\n    __TAG = tag or __TAG\n    if hc3_emulator or not color then self:tracef(fmt,...) \n    else\n      self:trace(\"<font color=\"..color..\">\"..fmt..\"</font>\") \n    end\n    __TAG = t\n  end\n\n  function self:encodeBase64(data)\n    local b='ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\n    return ((data:gsub('.', function(x) \n            local r,b='',x:byte() for i=8,1,-1 do r=r..(b%2^i-b%2^(i-1)>0 and '1' or '0') end\n            return r;\n          end)..'0000'):gsub('%d%d%d?%d?%d?%d?', function(x)\n          if (#x < 6) then return '' end\n          local c=0\n          for i=1,6 do c=c+(x:sub(i,i)=='1' and 2^(6-i) or 0) end\n          return b:sub(c+1,c+1)\n        end)..({ '', '==', '=' })[#data%3+1])\n  end\n\n-- Create basic authorisation data, used with http requests\n  function self:basicAuthorization(user,password) return \"Basic \"..self:encodeBase64(user..\":\"..password) end\n\n  local HC3version = nil\n  function self:version(version)                 -- Return/optional check HC3 version\n    if HC3version == nil then\n      if hc3_emulator then HC3version=\"5.040.37\"\n      else HC3version = api.get(\"/settings/info\").currentVersion.version end\n    end\n    if version then return version >= HC3version else return version end \n  end\n\n  local function notifyIf(self,p,text)\n    if self._NOTIFY then\n      local title = text:match(\"(.-)[:%s]\") or format(\"%s deviceId:%d\",self.id,self.name)\n      self:notify(p,title,text)\n    end\n    return text\n  end\n\n-- Enhanced debug functions converting tables to json and with formatting version\n  local _debug,_trace,_error,_warning = self.debug,self.trace,self.error,self.warning\n  function self:debug(...) if self._DEBUG then return _print(self,_debug,...) else return \"\" end end\n  function self:trace(...) if self._TRACE then return _print(self,_trace,...) else return \"\" end end\n  function self:error(...) return notifyIf(self,\"critical\",_print(self,_error,...)) end\n  function self:warning(...) return notifyIf(self,\"warning\",_print(self,_warning,...)) end\n  function self:debugf(fmt,...) if self._DEBUG then return _printf(self,_debug,fmt,...) else return \"\" end end\n  function self:tracef(fmt,...) return _printf(self,_trace,fmt,...) end\n  function self:errorf(fmt,...) return notifyIf(self,\"critical\",_printf(self,_error,fmt,...)) end\n  function self:warningf(fmt,...) return notifyIf(self,\"warning\",_printf(self,_warning,fmt,...)) end\n\n-- Like self:updateView but with formatting. Ex self:setView(\"label\",\"text\",\"Now %d days\",days)\n  function self:setView(elm,prop,fmt,...)\n    local str = _format(fmt,...)\n    self:updateView(elm,prop,str)\n  end\n\n-- Get view element value. Ex. self:getView(\"mySlider\",\"value\")\n  function self:getView(elm,prop)\n    assert(type(elm)=='string' and type(prop)=='string',\"Strings expected as arguments\")\n    local function find(s)\n      if type(s) == 'table' then\n        if s.name==elm then return s[prop]\n        else for _,v in pairs(s) do local r = find(v) if r then return r end end end\n      end\n    end\n    return find(api.get(\"/plugins/getView?id=\"..self.id)[\"$jason\"].body.sections)\n  end\n\n-- Change name of QA. Note, if name is changed the QA will restart\n  function self:setName(name)\n    if self.name ~= name then api.put(\"/devices/\"..self.id,{name=name}) end\n    self.name = name\n  end\n\n-- Set log text under device icon - optional timeout to clear the message\n  function self:setIconMessage(msg,timeout)\n    if self._logTimer then clearTimeout(self._logTimer) self._logTimer=nil end\n    self:updateProperty(\"log\", tostring(msg))\n    if timeout then \n      self._logTimer=setTimeout(function() self:updateProperty(\"log\",\"\"); self._logTimer=nil end,1000*timeout) \n    end\n  end\n\n-- Disable QA. Note, difficult to enable QA...\n  function self:setEnabled(bool)\n    local d = __fibaro_get_device(self.id)\n    if d.enabled ~= bool then api.put(\"/devices/\"..self.id,{enabled=bool}) end\n  end\n\n-- Hide/show QA. Note, if state is changed the QA will restart\n  function self:setVisible(bool) \n    local d = __fibaro_get_device(self.id)\n    if d.visible ~= bool then api.put(\"/devices/\"..self.id,{visible=bool}) end\n  end\n\n-- Add interfaces to QA. Note, if interfaces are added the QA will restart\n  local _addInterf = self.addInterfaces\n  function self:addInterfaces(interfaces) \n    local d,map = __fibaro_get_device(self.id),{}\n    for _,i in ipairs(d.interfaces or {}) do map[i]=true end\n    for _,i in ipairs(interfaces or {}) do\n      if not map[i] then\n        _addInterf(self,interfaces)\n        return\n      end\n    end\n  end\n\n  local _updateProperty = self.updateProperty\n  function self:updateProperty(prop,value)\n    local _props = self.properties\n    if _props==nil or _props[prop] ~= nil then\n      return _updateProperty(self,prop,value)\n    elseif self._PROPWARN then self:warningf(\"Trying to update non-existing property - %s\",prop) end\n  end\n-- Change type of QA. Note, if types is changed the QA will restart\n--function QuickApp:setType(typ)\n--  if self.typ ~= typ then api.put(\"/devices/\"..self.id,{type=typ}) end\n--  self.type = typ\n--end\n\n-- Add notification to notification center\n  local cachedNots = {}\n  function self:notify(priority, title, text, reuse)\n    assert(({info=true,warning=true,critical=true})[priority],\"Wrong 'priority' - info/warning/critical\")\n    if reuse==nil then reuse = self._NOTIFYREUSE end\n    local msgId = nil\n    local data = {\n      canBeDeleted = true,\n      wasRead = false,\n      priority = priority,\n      type = \"GenericDeviceNotification\",\n      data = {\n        deviceId = self.id,\n        subType = \"Generic\",\n        title = title,\n        text = tostring(text)\n      }\n    }\n    local nid = title..self.id\n    if reuse then\n      if cachedNots[nid] then\n        msgId = cachedNots[nid]\n      else\n        local notifications = api.get(\"/notificationCenter\")\n        for _,n in ipairs(notifications) do\n          if n.data and n.data.deviceId == self.id and n.data.title == title then\n            msgId = n.id\n            break\n          end\n        end\n      end\n    end\n    if msgId then\n      api.put(\"/notificationCenter/\"..msgId, data)\n    else\n      local d = api.post(\"/notificationCenter\", data)\n      if d then cachedNots[nid] = d.id end\n    end\n  end\n\n  local refs = {}\n  function self:INTERACTIVE_OK_BUTTON(ref) if refs[ref] then refs[ref]() end refs[ref]=nil end\n\n--  self:pushYesNo(\n--    839,                                          -- Mobile ID  (api.get(\"/iosDevices\"))\n--    \"Test\",                                       -- Title\n--    \"Please, press yes\",                          -- Message\n--    function() self:debug(\"User said Yes!\") end,  -- Callback function if user press yes\n--    5*60                                          -- Timout in seconds, after we ignore reply.\n--  )\n\n  function self:pushYesNo(mobileId,title,message,callback,timeout)\n    local ref = self._orgToString({}):match(\"%s(.*)\")\n    api.post(\"/mobile/push\", \n      {\n        category = \"YES_NO\", \n        title = title, \n        message = message, \n        service = \"Device\", \n        data = {\n          actionName = \"INTERACTIVE_OK_BUTTON\", \n          deviceId = self.id, \n          args = {ref}\n        }, \n        action = \"RunAction\", \n        mobileDevices = { mobileId }, \n      })\n    local timer = setTimeout(function() refs[ref]=nil; self:debug(\"Timeout\") end, timeout*1000)\n    timeout = timeout or 20*60\n    refs[ref]=function() clearTimeout(timer) callback() end\n  end\n\n  do -- Used for print device table structs - sortorder for device structs\n    local sortKeys = {\n      'id','name','roomID','type','baseType','enabled','visible','isPlugin','parentId','viewXml','configXml',\n      'interfaces','properties','view', 'actions','created','modified','sortOrder'\n    }\n    local sortOrder={}\n    for i,s in ipairs(sortKeys) do sortOrder[s]=\"\\n\"..string.char(i+64)..\" \"..s end\n    local function keyCompare(a,b)\n      local av,bv = sortOrder[a] or a, sortOrder[b] or b\n      return av < bv\n    end\n\n    function self:prettyJsonStruct(t)\n      local res = {}\n      local function isArray(t) return type(t)=='table' and t[1] end\n      local function isEmpty(t) return type(t)=='table' and next(t)==nil end\n      local function isKeyVal(t) return type(t)=='table' and t[1]==nil and next(t)~=nil end\n      local function printf(tab,fmt,...) res[#res+1] = string.rep(' ',tab)..string.format(fmt,...) end\n      local function pretty(tab,t,key)\n        if type(t)=='table' then\n          if isEmpty(t) then printf(0,\"[]\") return end\n          if isArray(t) then\n            printf(key and tab or 0,\"[\\n\")\n            for i,k in ipairs(t) do\n              local cr = pretty(tab+1,k,true)\n              if i ~= #t then printf(0,',') end\n              printf(tab+1,'\\n')\n            end\n            printf(tab,\"]\")\n            return true\n          end\n          local r = {}\n          for k,v in pairs(t) do r[#r+1]=k end\n          table.sort(r,keyCompare)\n          printf(key and tab or 0,\"{\\n\")\n          for i,k in ipairs(r) do\n            printf(tab+1,'\"%s\":',k)\n            local cr =  pretty(tab+1,t[k])\n            if i ~= #r then printf(0,',') end\n            printf(tab+1,'\\n')\n          end\n          printf(tab,\"}\")\n          return true\n        elseif type(t)=='number' then\n          printf(key and tab or 0,\"%s\",t) \n        elseif type(t)=='boolean' then\n          printf(key and tab or 0,\"%s\",t and 'true' or 'false') \n        elseif type(t)=='string' then\n          printf(key and tab or 0,'\"%s\"',t)\n        end\n      end\n      pretty(0,t,true)\n      return table.concat(res,\"\")\n    end\n  end\n\n  local IPaddress = nil\n  function self:getHC3IPaddress(name)\n    if IPaddress then return IPaddress end\n    if hc3_emulator then return hc3_emulator.IPaddress\n    else\n      name = name or \".*\"\n      local networkdata = api.get(\"/proxy?url=http://localhost:11112/api/settings/network\")\n      for n,d in pairs(networkdata.networkConfig or {}) do\n        if n:match(name) and d.enabled then IPaddress = d.ipConfig.ip; return IPaddress end\n      end\n    end\n  end\n\n  self._Events = {}\n  local eventHandlers = {}\n\n  function self._Events.postEvent(event)\n    for i=1,#eventHandlers do if eventHandlers[i](event) then return end end -- Handler returning true breaks chain\n  end\n\n  function self._Events.addEventHandler(handler,front)\n    for _,h in ipairs(eventHandlers) do if h==handler then return end end\n    if front then table.insert(eventHandlers,1,handler) else eventHandlers[#eventHandlers+1]=handler end\n  end\n\n  function self._Events.removeEventHandler(handler)\n    for i=1,#eventHandlers do if eventHandlers[i]==handler then table.remove(eventHandlers,i) return end end\n  end\n\n  function urlencode(str) -- very useful\n    if str then\n      str = str:gsub(\"\\n\", \"\\r\\n\")\n      str = str:gsub(\"([^%w %-%_%.%~])\", function(c)\n          return (\"%%%02X\"):format(string.byte(c))\n        end)\n      str = str:gsub(\" \", \"%%20\")\n    end\n    return str\t\n  end\n\n  local function syncGet(url,user,pwd)\n    local h,b = url:match(\"(.-)//(.*)\")\n    if pwd then\n      pwd = urlencode(user)..\":\"..urlencode(pwd)..\"@\"\n    else pwd = \"\" end\n    url=h..\"//\"..pwd..b\n    return api.get(\"/proxy?url=\"..urlencode(url))\n  end\n\n\n  local function copy(expr)\n    if type(expr)=='table' then\n      local r = {}\n      for k,v in pairs(expr) do r[k]=copy(v) end\n      return r\n    else return expr end\n  end\n\n  self.util = { copy = copy }\n\n  netSync = { HTTPClient = function (log)   \n      local self,queue,HTTP,key = {},{},net.HTTPClient(),0\n      local _request\n      local function dequeue()\n        table.remove(queue,1)\n        local v = queue[1]\n        if v then \n          if _debugFlags.netSync then self:debugf(\"netSync:Pop %s (%s)\",v[3],#queue) end\n          --setTimeout(function() _request(table.unpack(v)) end,1) \n          _request(table.unpack(v))\n        end\n      end\n      _request = function(url,params,key)\n        params = copy(params)\n        local uerr,usucc = params.error,params.success\n        params.error = function(status)\n          if _debugFlags.netSync then self:debugf(\"netSync:Error %s %s\",key,status) end\n          dequeue()\n          if params._logErr then self:errorf(\" %s:%s\",log or \"netSync:\",tojson(status)) end\n          if uerr then uerr(status) end\n        end\n        params.success = function(status)\n          if _debugFlags.netSync then self:debugf(\"netSync:Success %s\",key) end\n          dequeue()\n          if usucc then usucc(status) end\n        end\n        if _debugFlags.netSync then self:debugf(\"netSync:Calling %s\",key) end\n        HTTP:request(url,params)\n      end\n      function self:request(url,parameters)\n        key = key+1\n        if next(queue) == nil then\n          queue[1]='RUN'\n          _request(url,parameters,key)\n        else \n          if _debugFlags.netSync then self:debugf(\"netSync:Push %s\",key) end\n          queue[#queue+1]={url,parameters,key} \n        end\n      end\n      return self\n    end}\n\n  do\n    local settimeout,setinterval,encode,decode =  -- gives us a better error messages\n    setTimeout, setInterval, json.encode, json.decode\n    local oldClearTimout,oldSetTimout\n\n    if not hc3_emulator then -- Patch short-sighthed setTimeout...\n      clearTimeout,oldClearTimout=function(ref)\n        if type(ref)=='table' and ref[1]=='%EXT%' then ref=ref[2] end\n        oldClearTimout(ref)\n      end,clearTimeout\n\n      setTimeout,oldSetTimout=function(f,ms)\n        local ref,maxt={'%EXT%'},2147483648-1\n        local fun = function() -- wrap function to get error messages\n          local stat,res = pcall(f)\n          if not stat then \n            error(res,2)\n          end\n        end\n        if ms > maxt then\n          ref[2]=oldSetTimout(function() ref[2 ]=setTimeout(fun,ms-maxt)[2] end,maxt)\n        else ref[2 ]=oldSetTimout(fun,math.floor(ms+0.5)) end\n        return ref\n      end,setTimeout\n\n      function setInterval(fun,ms) -- can't manage looong intervals\n        return setinterval(function()\n            local stat,res = pcall(fun)\n            if not stat then \n              error(res,2)\n            end\n          end,math.floor(ms+0.5))\n      end\n      function json.decode(...)\n        local stat,res = pcall(decode,...)\n        if not stat then error(res,2) else return res end\n      end\n      function json.encode(...)\n        local stat,res = pcall(encode,...)\n        if not stat then error(res,2) else return res end\n      end\n    end\n  end\n\n  local traceFuns = {\n    'call','get','getValue'\n  }\n\n  do \n    local p = print\n    function print(a,...) \n      if a~='onAction: ' or self._ONACTIONLOG then\n        p(a,...) \n      end\n    end\n  end\nend"},{"name":"Toolbox_ui","isMain":false,"isOpen":false,"content":"--[[\n  Toolbox UI.\n  \n  Functions to manipulate UI\n\n--]]\n\nToolbox_Module = Toolbox_Module or {}\nToolbox_Module.ui = {\n  name = \"UI functions\",\n  author = \"jan@gabrielsson.com\",\n  version = \"0.1\"\n}\n\nfunction Toolbox_Module.ui.init(self)\n  if Toolbox_Module.ui.inited then return Toolbox_Module.ui.inited end\n  Toolbox_Module.ui.inited = true\n  \n  local format = string.format\n  local function mapf(f,l) for _,e in ipairs(l) do f(e) end; end\n  local function map(f,l) local r={}; for _,e in ipairs(l) do r[#r+1]=f(e) end; return r end\n  local function traverse(o,f)\n    if type(o) == 'table' and o[1] then\n      for _,e in ipairs(o) do traverse(e,f) end\n    else f(o) end\n  end\n\n \n  local ELMS = {\n    button = function(d,w)\n      return {name=d.name,style={weight=d.weight or w or \"0.50\"},text=d.text,type=\"button\"}\n    end,\n    select = function(d,w)\n      if d.options then map(function(e) e.type='option' end,d.options) end\n      return {name=d.name,style={weight=d.weight or w or \"0.50\"},text=d.text,type=\"select\", selectionType='single',\n        options = d.options or {{value=\"1\", type=\"option\", text=\"option1\"}, {value = \"2\", type=\"option\", text=\"option2\"}},\n        values = d.values or { \"option1\" }\n      }\n    end,\n    multi = function(d,w)\n      if d.options then map(function(e) e.type='option' end,d.options) end\n      return {name=d.name,style={weight=d.weight or w or \"0.50\"},text=d.text,type=\"select\", selectionType='multi',\n        options = d.options or {{value=\"1\", type=\"option\", text=\"option2\"}, {value = \"2\", type=\"option\", text=\"option3\"}},\n        values = d.values or { \"option3\" }\n      }\n    end,\n    image = function(d,w)\n      return {name=d.name,style={dynamic=\"1\"},type=\"image\", url=d.url}\n    end,\n    switch = function(d,w)\n      return {name=d.name,style={weight=w or d.weight or \"0.50\"},type=\"switch\", value=d.value or \"true\"}\n    end,\n    option = function(d,w)\n      return {name=d.name, type=\"option\", value=d.value or \"Hupp\"}\n    end,\n    slider = function(d,w)\n      return {name=d.name,step=tostring(d.step),value=tostring(d.value),max=tostring(d.max),min=tostring(d.min),style={weight=d.weight or w or \"1.2\"},text=d.text,type=\"slider\"}\n    end,\n    label = function(d,w)\n      return {name=d.name,style={weight=d.weight or w or \"1.2\"},text=d.text,type=\"label\"}\n    end,\n    space = function(d,w)\n      return {style={weight=w or \"0.50\"},type=\"space\"}\n    end\n  }\n\n  local function mkRow(elms,weight)\n    local comp = {}\n    if elms[1] then\n      local c = {}\n      local width = format(\"%.2f\",1/#elms)\n      if width:match(\"%.00\") then width=width:match(\"^(%d+)\") end\n      for _,e in ipairs(elms) do c[#c+1]=ELMS[e.type](e,width) end\n      if #elms > 1 then comp[#comp+1]={components=c,style={weight=\"1.2\"},type='horizontal'}\n      else comp[#comp+1]=c[1] end\n      comp[#comp+1]=ELMS['space']({},\"0.5\")\n    else\n      comp[#comp+1]=ELMS[elms.type](elms,\"1.2\")\n      comp[#comp+1]=ELMS['space']({},\"0.5\")\n    end\n    return {components=comp,style={weight=weight or \"1.2\"},type=\"vertical\"}\n  end\n\n  local function mkViewLayout(list,height)\n    local items = {}\n    for _,i in ipairs(list) do items[#items+1]=mkRow(i) end\n--    if #items == 0 then  return nil end\n    return\n    { ['$jason'] = {\n        body = {\n          header = {\n            style = {height = tostring(height or #list*50)},\n            title = \"quickApp_device_23\"\n          },\n          sections = {\n            items = items\n          }\n        },\n        head = {\n          title = \"quickApp_device_23\"\n        }\n      }\n    }\n  end\n\n  self.mkViewLayout = mkViewLayout\n  local function transformUI(UI) -- { button=<text> } => {type=\"button\", name=<text>}\n    traverse(UI,\n      function(e)\n        if e.button then e.name,e.type=e.button,'button'\n        elseif e.slider then e.name,e.type=e.slider,'slider'\n        elseif e.select then e.name,e.type=e.select,'select'\n        elseif e.switch then e.name,e.type=e.switch,'switch'\n        elseif e.multi then e.name,e.type=e.multi,'multi'\n        elseif e.option then e.name,e.type=e.option,'option'\n        elseif e.image then e.name,e.type=e.image,'image'\n        elseif e.label then e.name,e.type=e.label,'label'\n        elseif e.space then e.weight,e.type=e.space,'space' end\n      end)\n    return UI\n  end\n\n  local function uiStruct2uiCallbacks(UI)\n    local cb = {}\n    --- \"callback\": \"self:button1Clicked()\",\n    traverse(UI,\n      function(e)\n        if e.name then\n          -- {callback=\"foo\",name=\"foo\",eventType=\"onReleased\"}\n          local defu = e.button and \"Clicked\" or e.slider and \"Change\" or (e.switch or e.select) and \"Toggle\" or \"\"\n          local deff = e.button and \"onReleased\" or e.slider and \"onChanged\" or (e.switch or e.select) and \"onToggled\" or \"\"\n          local cbt = e.name..defu\n          if e.onReleased then\n            cbt = e.onReleased\n          elseif e.onChanged then\n            cbt = e.onChanged\n          elseif e.onToggled then\n            cbt = e.onToggled\n          end\n          if e.button or e.slider or e.switch or e.select then\n            cb[#cb+1]={callback=cbt,eventType=deff,name=e.name}\n          end\n        end\n      end)\n    return cb\n  end\n\n  function self:updateViewLayout(id,UI,forceUpdate) --- This may not work anymore....\n    transformUI(UI)\n    local cb = api.get(\"/devices/\"..id).properties.uiCallbacks or {}\n    local viewLayout = mkViewLayout(UI)\n    local newcb = uiStruct2uiCallbacks(UI)\n    if forceUpdate then\n      cb = newcb -- just replace uiCallbacks with new elements callbacks\n    else\n      local mapOrg = {}\n      for _,c in ipairs(cb) do mapOrg[c.name]=c.callback end -- existing callbacks, map name->callback\n      for _,c in ipairs(newcb) do if mapOrg[c.name] then c.callback=mapOrg[c.name] end end\n      cb = newcb -- save exiting elemens callbacks\n    end\n    if not cb[1] then cb = nil end\n    return api.put(\"/devices/\"..id,{\n        properties = {\n          viewLayout = viewLayout,\n          uiCallbacks = cb},\n      })\n  end\n\n   function self:makeInitialUIProperties(UI,vars,height)\n    local ip = {}\n    vars = vars or {}\n    transformUI(UI)\n    ip.viewLayout = mkViewLayout(UI,height)\n    ip.uiCallbacks = uiStruct2uiCallbacks(UI)\n    ip.apiVersion = \"1.2\"\n    local varList = {}\n    for n,v in pairs(vars) do varList[#varList+1]={name=n,value=v} end\n    ip.quickAppVariables = varList\n    ip.typeTemplateInitialized=true\n    return ip\n  end\n\n  function self:insertLabel(name,text,pos)\n    local id = self.id\n    local vl = api.get(\"/devices/\"..id).properties.viewLayout\n    local v = vl['$jason'].body.sections.items\n    for _,i in ipairs(v) do\n      for _,j in ipairs(i.components or {}) do\n        if j.type=='label' and j.name==name then return false end\n      end\n    end\n    local elm = {name=name,style={weight=\"1.2\"},text=text,type=\"label\"}\n    table.insert(v,pos,\n      {\n        components={\n          elm,\n          {style={weight=\"0.5\"},type=\"space\"}\n        },\n        style={weight=\"1.2\"},\n        type=\"vertical\"\n      })\n    return api.put(\"/devices/\"..id,{properties={viewLayout=vl}})\n  end\n\n  function self:removeLabel(name)\n    local id = self.id\n    local vl = api.get(\"/devices/\"..id).properties.viewLayout\n    local v = vl['$jason'].body.sections.items\n    for _,i in ipairs(v) do\n      for _,j in ipairs(i.components or {}) do\n        if j.type=='label' and j.name==name then\n          table.remove(v,i)\n          return api.put(\"/devices/\"..id,{properties={viewLayout=vl}})\n        end\n      end\n    end\n  end\n\nend"}]}